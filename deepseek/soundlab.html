<!DOCTYPE html>
<html>

<head>
    <title>🎙️ SoundLab 在线声音分析</title>
    <style>
        body {
            max-width: 820px;
            margin: 20px auto;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background-color: #f5f5f5;
            color: #333;
        }
        h1 {
            text-align: center;
            color: #333;
            margin: 0px;
        }
        .dashboard {}
        .card {
            border-radius: 16px;
        }
        .card h3 {
            font-size: 1.2rem;
            margin: 0px;
        }
        .controls {
            display: flex;
            justify-content: center;
            gap: 10px;
            margin-bottom: 20px;
        }
        button {
            padding: 10px 20px;
            margin: 5px;
            border: none;
            border-radius: 5px;
            background-color: #007bff;
            color: white;
            cursor: pointer;
            transition: background-color 0.3s ease;
        }
        button:hover {
            background-color: #0056b3;
        }
        button:disabled {
            background-color: #cccccc;
            cursor: not-allowed;
        }
        #status {
            text-align: center;
            color: #666;
            margin: 10px 0;
            font-size: 14px;
        }
        canvas {
            background: #000;
            margin: 10px 0;
            border-radius: 5px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        }
        #audioPlayer {
            width: 100%;
            margin-top: 20px;
            border-radius: 5px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        }
        .container {
            background: white;
            padding: 10px;
            border-radius: 10px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        }
        .recordings-list {
            margin-top: 0px;
        }
        .recording-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 4px;
            border-bottom: 1px solid #ddd;
        }
        .recording-item:hover {
            background-color: #DBEAFE;
            box-shadow: 0 2px 2px rgba(0, 0, 0, 0.1);
        }
        .recording-item:last-child {
            border-bottom: none;
        }
        .recording-item button {
            background-color: #28a745;
            margin-left: 10px;
        }
        .recording-item button.delete-btn {
            background-color: #dc3545;
        }
        .recording-title {
            width: 150px;
        }
        .recording-img{
            width: 520px;
        }
        .recording-tool {
            width: 120px;
            text-align:center;
        }
        .recording-item img {
            background-color: #333;
            width: 500px;
        }
        /* 新增样式 */
        .compare-section {
            padding: 20px;
            background: #f8f9fa;
            border-radius: 10px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }
        .compare-controls {
            display: grid;
            grid-template-columns: 1fr 1fr auto;
            gap: 10px;
            margin: 15px 0;
        }
        select {
            padding: 8px;
            border: 1px solid #ddd;
            border-radius: 4px;
        }
        .result-box {
            padding: 15px;
            background: white;
            border-radius: 8px;
            border: 1px solid #eee;
            min-height: 50px;
        }
        .similar {
            color: #28a745;
            font-weight: bold;
        }
        .dissimilar {
            color: #dc3545;
            font-weight: bold;
        }
        .similarity-meter {
            background: #eee;
            height: 30px;
            border-radius: 15px;
            position: relative;
            margin: 15px 0;
        }
        .similarity-meter .bar {
            background: linear-gradient(90deg, #dc3545, #ffc107, #28a745);
            height: 100%;
            border-radius: 15px;
            transition: width 0.5s ease;
        }
        .similarity-meter span {
            position: absolute;
            left: 50%;
            top: 50%;
            transform: translate(-50%, -50%);
            color: white;
            text-shadow: 0 1px 2px rgba(0,0,0,0.3);
        }
        .feature-comparison {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin-top: 20px;
        }

        .medium {
            color: #ffc107;
        }
    </style>

</head>
<body>
    <div class="container">
        <h1 title="声音的三要素：音高、音色、响度">🎙️ ️SoundLab 在线声音分析</h1>
        <div class="dashboard">
            <div class="card">
                <h3>📈 实时波形</h3>
                <canvas id="waveform" width="800" height="150" title="波形图：振幅为响度"></canvas>
            </div>

            <div class="card">
                <h3>🌈 频谱分析</h3>
                <canvas id="spectrum" width="800" height="150" title="频谱图：振幅为频率"></canvas>
            </div>

            <!-- 新增 MFCC 特征显示区域 -->
            <div class="card">
                <h3>🎵 MFCC 特征</h3>
                <canvas id="mfcc" width="800" height="150" title="倒谱图：音色"></canvas>
            </div>
        </div>
        <div class="controls">
            <button id="startBtn">开始录音</button>
            <button id="stopBtn" disabled>停止录音</button>
            <button  type = "button" onclick="savechat()"   title="保存到服务器上" >
            <i class="fa fa-save" aria-hidden="true"></i> 保存</button>
            <span class="sp"></span>
            <button  onclick="returnurl()" title="返回到学案页面">
            <i class="fa fa-reply" aria-hidden="true"></i> 返回</button>  

        </div>
        <div id="status">准备就绪</div>
        <audio id="audioPlayer" controls hidden></audio>

        <div class="recordhistory">
            <div class="recordings-list">
                <h3>📁 录音列表</h3>
                <div id="recordings"></div>
            </div>
            <!-- 新增比较功能区域 -->
            <div class="compare-section">
                <h3>🔊 声音相似度对比</h3>
                <div class="compare-controls">
                    <select id="recording1">
                        <option value="">选择第一个录音</option>
                    </select>
                    <select id="recording2">
                        <option value="">选择第二个录音</option>
                    </select>
                    <button onclick="compareRecordings()">开始比较</button>
                </div>
                <div id="result" class="result-box"></div>
            </div>
        </div>
    </div>

    <script>                    
        const startBtn = document.getElementById('startBtn');
        const stopBtn = document.getElementById('stopBtn');
        const status = document.getElementById('status');
        const waveformCanvas = document.getElementById('waveform');
        const spectrumCanvas = document.getElementById('spectrum');
        const mfccCanvas = document.getElementById('mfcc');
        const audioPlayer = document.getElementById('audioPlayer');
        const recordingsList = document.getElementById('recordings');

        let audioContext, analyser, mediaRecorder, chunks = [];
        let isRecording = false;
        let isPlaying = false;
        let recordings = [];
        let mfccFeatures = [];
        let featureBuffer = [];

        // 初始化分析器
        function initAnalyser(source) {
            analyser = audioContext.createAnalyser();
            analyser.fftSize = 2048;

            const gainNode = audioContext.createGain();
            gainNode.gain.value = 0;

            source.connect(analyser);
            analyser.connect(gainNode);
            gainNode.connect(audioContext.destination);
        }

        // 绘制波形
        function drawWaveform() {
            const ctx = waveformCanvas.getContext('2d');
            ctx.clearRect(0, 0, waveformCanvas.width, waveformCanvas.height);

            if (analyser) {
                const bufferLength = analyser.fftSize;
                const dataArray = new Uint8Array(bufferLength);
                analyser.getByteTimeDomainData(dataArray);

                ctx.beginPath();
                ctx.lineWidth = 2;
                ctx.strokeStyle = '#0f0';

                const sliceWidth = waveformCanvas.width * 1.0 / bufferLength;
                let x = 0;

                for (let i = 0; i < bufferLength; i++) {
                    const v = dataArray[i] / 128.0;
                    const y = v * waveformCanvas.height / 2;

                    if (i === 0) ctx.moveTo(x, y);
                    else ctx.lineTo(x, y);

                    x += sliceWidth;
                }

                ctx.stroke();
            }

            if (isRecording || isPlaying) {
                requestAnimationFrame(drawWaveform);
            }
        }

        // 绘制频谱
        function drawSpectrum() {
            const ctx = spectrumCanvas.getContext('2d');
            ctx.clearRect(0, 0, spectrumCanvas.width, spectrumCanvas.height);

            if (analyser) {
                const bufferLength = analyser.frequencyBinCount;
                const dataArray = new Uint8Array(bufferLength);
                analyser.getByteFrequencyData(dataArray);

                const barWidth = (spectrumCanvas.width / bufferLength) * 2.5;
                let x = 0;

                for (let i = 0; i < bufferLength; i++) {
                    const barHeight = dataArray[i];
                    ctx.fillStyle = `hsl(${i * 2}, 100%, 50%)`;
                    ctx.fillRect(x, spectrumCanvas.height - barHeight, barWidth, barHeight);
                    x += barWidth + 1;
                }
                
                // 计算 MFCC 特征
                mfccFeatures = calculateMFCC(dataArray, audioContext.sampleRate);
                drawMFCC();
            }

            if (isRecording || isPlaying) {
                requestAnimationFrame(drawSpectrum);
            }
        }

        // 优化的MFCC特征提取 - 专注于音色特征
        function calculateMFCC(spectrumData, sampleRate) {
            const numFilters = 26;
            const numCoefficients = 13;
            
            // 转换为功率谱
            const powerSpectrum = Array.from(spectrumData).map(value => {
                // 转换为幅度并计算功率
                const amplitude = value / 255.0;
                return amplitude * amplitude;
            });
            
            // 应用梅尔滤波器组
            const melFilters = createMelFilterBank(numFilters, powerSpectrum.length, sampleRate);
            const melEnergies = [];
            
            for (let i = 0; i < numFilters; i++) {
                let sum = 0;
                for (let j = 0; j < powerSpectrum.length; j++) {
                    sum += powerSpectrum[j] * melFilters[i][j];
                }
                // 使用对数压缩
                melEnergies.push(Math.log(Math.max(sum, 1e-10)));
            }
            
            // 应用DCT得到MFCC系数
            const mfcc = applyDCT(melEnergies);
            
            // 返回所有13个系数（包括能量系数）
            return mfcc.slice(0, numCoefficients);
        }
        
        // 创建梅尔滤波器组
        function createMelFilterBank(numFilters, fftSize, sampleRate) {
            const melFilters = [];
            const maxFreq = sampleRate / 2;
            
            // 转换为梅尔频率
            const minMel = 0;
            const maxMel = 2595 * Math.log10(1 + maxFreq / 700);
            
            // 在梅尔刻度上均匀分布
            const melPoints = [];
            for (let i = 0; i <= numFilters + 1; i++) {
                melPoints.push(minMel + (i / (numFilters + 1)) * (maxMel - minMel));
            }
            
            // 转换回Hz
            const hzPoints = melPoints.map(mel => 700 * (Math.pow(10, mel / 2595) - 1));
            
            // 转换为频点
            const binPoints = hzPoints.map(hz => Math.floor((fftSize) * hz / sampleRate));
            
            // 创建三角滤波器
            for (let i = 0; i < numFilters; i++) {
                const filter = new Array(fftSize).fill(0);
                const left = binPoints[i];
                const center = binPoints[i + 1];
                const right = binPoints[i + 2];
                
                // 创建三角滤波器响应
                for (let j = left; j <= center; j++) {
                    if (j >= 0 && j < fftSize) {
                        filter[j] = (j - left) / (center - left);
                    }
                }
                for (let j = center; j <= right; j++) {
                    if (j >= 0 && j < fftSize) {
                        filter[j] = 1 - (j - center) / (right - center);
                    }
                }
                
                melFilters.push(filter);
            }
            
            return melFilters;
        }
        
        // DCT变换
        function applyDCT(signal) {
            const N = signal.length;
            const coefficients = [];
            
            for (let k = 0; k < N; k++) {
                let sum = 0;
                for (let n = 0; n < N; n++) {
                    sum += signal[n] * Math.cos(Math.PI * k / N * (n + 0.5));
                }
                coefficients.push(sum);
            }
            
            return coefficients;
        }

        // 绘制 MFCC 特征
        function drawMFCC() {
            const ctx = mfccCanvas.getContext('2d');
            ctx.clearRect(0, 0, mfccCanvas.width, mfccCanvas.height);

            if (mfccFeatures.length > 0) {
                const numCoefficients = mfccFeatures.length;
                const barWidth = mfccCanvas.width / numCoefficients;
                const maxHeight = mfccCanvas.height;
                
                // 归一化显示
                const maxVal = Math.max(...mfccFeatures.map(Math.abs));
                
                for (let i = 0; i < numCoefficients; i++) {
                    const normalizedValue = mfccFeatures[i] / maxVal;
                    const barHeight = Math.abs(normalizedValue) * maxHeight * 0.8;
                    const y = maxHeight - barHeight;
                    
                    ctx.fillStyle = `hsl(${i * 30}, 100%, 60%)`;
                    ctx.fillRect(i * barWidth, y, barWidth - 1, barHeight);
                }
            }

            if (isRecording || isPlaying) {
                requestAnimationFrame(drawMFCC);
            }
        }

        let recordnum = 0;

        // 添加录音到列表
        function addRecording(blob, duration) {
            recordnum++;
            const recording = {
                id: Date.now(),
                name: recordnum,
                blob: blob,
                duration: duration,
                timestamp: new Date().toLocaleString(),
                waveform: waveformCanvas.toDataURL(),
                spectrum: spectrumCanvas.toDataURL(),
                mfcc: mfccCanvas.toDataURL(),
                mfccFeature: [...mfccFeatures] // 深拷贝MFCC特征
            };

            recordings.push(recording);
            renderRecordings();
            updateRecordingSelector();
        }

        // 渲染录音列表
        function renderRecordings() {
            recordingsList.innerHTML = recordings.map(rec => `
                <div class="recording-item">
                    <div class="recording-title">
                        <h4>录音${rec.name}</h4>
                        <div>${rec.timestamp}</div>
                        <div>${rec.duration.toFixed(2)}秒</div>
                    </div>
                    <div class="recording-img">
                        <img src="${rec.waveform}" title="波形图：振幅为响度"/>
                        <img src="${rec.spectrum}"  title="频谱图：振幅为频率"/>
                        <img src="${rec.mfcc}"  title="倒谱图：音色"/>
                    </div>
                    <div  class="recording-tool">
                        <button onclick="playRecording(${rec.id})">播放</button>
                        <button class="delete-btn" onclick="deleteRecording(${rec.id})">删除</button>
                    </div>
                </div>
            `).join('');
        }

        // 播放录音
        window.playRecording = function (id) {
            const recording = recordings.find(rec => rec.id === id);
            if (recording) {
                const url = URL.createObjectURL(recording.blob);
                audioPlayer.src = url;
                audioPlayer.hidden = true;
                audioPlayer.play();
            }
        };

        // 删除录音
        window.deleteRecording = function (id) {
            recordings = recordings.filter(rec => rec.id !== id);
            renderRecordings();
            updateRecordingSelector();
        };

        // 开始录音
        startBtn.addEventListener('click', async () => {
            try {
                const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
                mediaRecorder = new MediaRecorder(stream);
                chunks = [];

                const startTime = Date.now();

                mediaRecorder.ondataavailable = e => chunks.push(e.data);
                mediaRecorder.onstop = async () => {
                    const duration = (Date.now() - startTime) / 1000;
                    const blob = new Blob(chunks, { type: 'audio/webm' });
                    addRecording(blob, duration);
                    status.textContent = "录音已保存";
                };

                initAnalyser(audioContext.createMediaStreamSource(stream));
                mediaRecorder.start();
                isRecording = true;

                startBtn.disabled = true;
                stopBtn.disabled = false;
                status.textContent = "录音中...";
                drawWaveform();
                drawSpectrum();

            } catch (err) {
                status.textContent = "错误: " + err.message;
            }
        });

        // 停止录音
        stopBtn.addEventListener('click', () => {
            if (mediaRecorder && isRecording) {
                mediaRecorder.stop();
                isRecording = false;
                
                mediaRecorder.stream.getTracks().forEach(track => track.stop());
                
                startBtn.disabled = false;
                stopBtn.disabled = true;
                status.textContent = "保存中...";
            }
        });

        // 播放控制
        audioPlayer.addEventListener('play', async () => {
            if (!audioPlayer.src) return;

            try {
                if (audioContext) audioContext.close();
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
                isPlaying = true;
                
                const source = audioContext.createMediaElementSource(audioPlayer);
                initAnalyser(source);
                drawWaveform();
                drawSpectrum();
                
            } catch (err) {
                console.error('播放分析错误:', err);
            }
        });

        audioPlayer.addEventListener('pause', () => {
            isPlaying = false;
        });

        audioPlayer.addEventListener('ended', () => {
            isPlaying = false;
            URL.revokeObjectURL(audioPlayer.src);
        });

        // 更新选择器
        function updateRecordingSelector() {
            const selector1 = document.getElementById('recording1');
            const selector2 = document.getElementById('recording2');

            selector1.innerHTML = '<option value="">选择第一个录音</option>';
            selector2.innerHTML = '<option value="">选择第二个录音</option>';

            recordings.forEach(rec => {
                const optionText = `录音${rec.name} (${rec.duration.toFixed(1)}秒)`;
                
                const option1 = new Option(optionText, rec.id);
                const option2 = new Option(optionText, rec.id);
                
                selector1.add(option1);
                selector2.add(option2);
            });
        }

        // 改进的MFCC特征相似度计算
        window.calculateMFCCSimilarity = function(vecA, vecB) {
            if (!vecA || !vecB || vecA.length !== vecB.length) {
                return 0;
            }
            
            // 1. 计算余弦相似度
            let dotProduct = 0;
            let normA = 0;
            let normB = 0;
            
            for (let i = 0; i < vecA.length; i++) {
                dotProduct += vecA[i] * vecB[i];
                normA += vecA[i] * vecA[i];
                normB += vecB[i] * vecB[i];
            }
            
            if (normA === 0 || normB === 0) return 0;
            
            const cosineSim = dotProduct / (Math.sqrt(normA) * Math.sqrt(normB));
            
            // 2. 计算欧氏距离相似度（归一化）
            let squaredDistance = 0;
            for (let i = 0; i < vecA.length; i++) {
                squaredDistance += Math.pow(vecA[i] - vecB[i], 2);
            }
            const euclideanDist = Math.sqrt(squaredDistance);
            
            // 3. 归一化欧氏距离到相似度（假设最大距离为10）
            const maxDistance = 10;
            const euclideanSim = Math.max(0, 1 - euclideanDist / maxDistance);
            
            // 4. 综合两种相似度（余弦相似度权重更高）
            const combinedSimilarity = cosineSim * 0.7 + euclideanSim * 0.3;
            
            return Math.max(0, Math.min(1, combinedSimilarity));
        };

        // 改进的声音比较函数 - 专注于MFCC特征
        window.compareRecordings = function() {
            const resultDiv = document.getElementById('result');
            const id1 = document.getElementById('recording1').value;
            const id2 = document.getElementById('recording2').value;

            if (!id1 || !id2) {
                resultDiv.innerHTML = '<div class="dissimilar">请选择两个录音文件</div>';
                return;
            }

            const rec1 = recordings.find(r => r.id == id1);
            const rec2 = recordings.find(r => r.id == id2);

            if (!rec1?.mfccFeature || !rec2?.mfccFeature) {
                resultDiv.innerHTML = '<div class="dissimilar">MFCC特征数据不完整</div>';
                return;
            }

            try {
                // 直接使用MFCC特征计算相似度
                const mfccSimilarity = calculateMFCCSimilarity(rec1.mfccFeature, rec2.mfccFeature);
                const similarityPercent = mfccSimilarity * 100;
                
                console.log("MFCC特征1:", rec1.mfccFeature);
                console.log("MFCC特征2:", rec2.mfccFeature);
                console.log("MFCC相似度:", mfccSimilarity);
                
                renderComparisonResult(similarityPercent, rec1, rec2);
                
            } catch (error) {
                console.error('比较出错:', error);
                resultDiv.innerHTML = '<div class="dissimilar">比较过程发生错误</div>';
            }
        };

        // 结果显示
        function renderComparisonResult(similarity, rec1, rec2) {
            const resultDiv = document.getElementById('result');
            const similarityText = similarity.toFixed(1) + '%';
            
            let resultClass = 'dissimilar';
            if (similarity > 75) resultClass = 'similar';
            else if (similarity > 50) resultClass = 'medium';
            
            resultDiv.innerHTML = `
                <div class="${resultClass}">
                    <h4>基于MFCC特征的声音相似度分析</h4>
                    <div class="similarity-meter">
                        <div class="bar" style="width: ${Math.min(similarity, 100)}%">
                            <span>${similarityText}</span>
                        </div>
                    </div>
                    <div style="margin-top: 15px; font-size: 14px; text-align: left;">
                        <div><strong>分析说明：</strong></div>
                        <div>• 使用13维MFCC特征（包含能量系数）</div>
                        <div>• 综合余弦相似度和欧氏距离相似度</div>
                        <div>• 主要反映音色相似度</div>
                        <div>录音${rec1.name} vs 录音${rec2.name}</div>
                    </div>
                </div>
            `;
        }

        // 占位函数
        function savechat() {
            alert("保存功能需要后端支持");
        }

        function returnurl() {
            alert("返回功能需要具体实现");
        }

    </script>
</body>

</html>